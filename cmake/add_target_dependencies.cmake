# Required to resolve issue with CPack and dpkg-shlibdeps:
# CPackDeb.cmake creates debian directory only, but DEBIAN is needed for dpkg-shlibdeps to find
# private targets
# See https://cmake.org/pipermail/cmake/2016-March/063124.html and
# https://public.kitware.com/Bug/view.php?id=12431
# Fixed with https://github.com/Kitware/CMake/commit/b8263a2f8d6df42b2a37c2efc2f7a3ac2b1d658a#diff-f6dcbb017b98fd0dba2e1836fbf6a92c
# (CMake 3.6.0)

# list command no longer ignores empty elements
if(POLICY CMP0007)
  cmake_policy(SET CMP0007 NEW)
endif()

# - Find dpkg-shlibdeps
find_program(SHLIBDEPS_EXECUTABLE dpkg-shlibdeps)

if (NOT SHLIBDEPS_EXECUTABLE)
  message(FATAL_ERROR "Couldn't find dpkg-shlibdeps Debian utility")
endif()

# Generating binary list - Get type of all install files
execute_process(COMMAND find -type f
  COMMAND xargs file
  WORKING_DIRECTORY ${BINARY_DIR}
  OUTPUT_VARIABLE DEB_INSTALL_FILES)

# Convert to CMake list
string(REGEX REPLACE "\n" ";" DEB_INSTALL_FILES ${DEB_INSTALL_FILES})

set(EXCLUDE_PATTERNS "(.*)CMakeFiles(.*)")

if (EXCLUDE_PATTERN)
 string(REGEX REPLACE "\\|" ";" EXCLUDE_PATTERN ${EXCLUDE_PATTERN})
endif()

foreach (pattern ${EXCLUDE_PATTERN})
  list(APPEND EXCLUDE_PATTERNS "(.*)${pattern}(.*)")
endforeach()

# Only dynamically linked ELF files are included
# Extract only file name infront of ":"
foreach ( _FILE ${DEB_INSTALL_FILES})
  if ( ${_FILE} MATCHES "ELF.*dynamically linked")
    foreach (pattern ${EXCLUDE_PATTERNS})
      string(REGEX MATCH "${pattern}" has_match ${_FILE})
      if (has_match)
        break()
      endif()
    endforeach()
    if (NOT has_match)
      string(REGEX MATCH "(^.*):" _FILE_NAME ${_FILE})
      list(APPEND DEB_BINARY_FILES "../${CMAKE_MATCH_1}")
    endif()
  endif()
endforeach()

# Function to add a list of dependencies to a CPack configuration file
function(write_dependencies_to_file DESTINATION_FILE DEPENDENCIES)
  file(READ ${DESTINATION_FILE} CPACK_CONFIG)

  # Convert file to CMake list
  string(REGEX REPLACE ";" "\\\;" CPACK_CONFIG "${CPACK_CONFIG}")
  string(REGEX REPLACE "\n" ";" CPACK_CONFIG "${CPACK_CONFIG}")

  file(WRITE ${DESTINATION_FILE} "")

  # Rewrite all lines to file except the one including already available dependencies (if available)
  foreach(line ${CPACK_CONFIG})
    if(line MATCHES "(.*)CPACK_DEBIAN_PACKAGE_DEPENDS(.*)")
      string(REGEX MATCH "\"(.*)\"" OLD_DEPENDENCIES "${line}")
    else()
      string(REGEX REPLACE "\\\;" ";" line "${line}")
      file(APPEND ${DESTINATION_FILE} "${line}\n")
    endif()
  endforeach()

  # Prepare CMake list of old and new dependencies
  string(REGEX REPLACE "\"" "" OLD_DEPENDENCIES "${OLD_DEPENDENCIES}")
  string(REGEX REPLACE "," ";" OLD_DEPENDENCIES "${OLD_DEPENDENCIES}")
  string(REGEX REPLACE "," ";" DEPENDENCIES "${DEPENDENCIES}")

  # Merge them in a single dependency list
  set(DEPENDENCY_LIST "")

  foreach (dep ${OLD_DEPENDENCIES})
      # Remove leading and trainling spaces
      string(STRIP ${dep} dep)
      list(APPEND DEPENDENCY_LIST ${dep})
  endforeach()
    
  foreach (dep ${DEPENDENCIES})
      # Remove leading and trainling spaces
      string(STRIP ${dep} dep)
      list(FIND DEPENDENCY_LIST "${dep}" index)
      if (${index} EQUAL -1)
        list(APPEND DEPENDENCY_LIST ${dep})
      endif()
  endforeach()
  
  # Write new dependency list back to file
  string(REGEX REPLACE ";" ", " DEPENDENCY_LIST "${DEPENDENCY_LIST}")
  file(APPEND ${DESTINATION_FILE} "SET(CPACK_DEBIAN_PACKAGE_DEPENDS \"${DEPENDENCY_LIST}\")")
endfunction()

if (DEB_BINARY_FILES)
  # Create blank control file for running dpkg-shlibdeps
  # There might be some other way to invoke dpkg-shlibdeps without creating this file
  # but standard debian package should not have anything that can collide with this file or directory
  file(MAKE_DIRECTORY ${BINARY_DIR}/tmp/DEBIAN)
  file(MAKE_DIRECTORY ${BINARY_DIR}/tmp/debian)
  file(WRITE ${BINARY_DIR}/tmp/debian/control "")

  # Execute dpkg-shlibdeps
  # --ignore-missing-info : allow dpkg-shlibdeps to run even if some libs do not belong to a package
  # -O : print to STDOUT
  execute_process(COMMAND ${SHLIBDEPS_EXECUTABLE} --ignore-missing-info -O ${DEB_BINARY_FILES}
    WORKING_DIRECTORY "${BINARY_DIR}/tmp"
    OUTPUT_VARIABLE SHLIBDEPS_OUTPUT
    RESULT_VARIABLE SHLIBDEPS_RESULT
    ERROR_VARIABLE SHLIBDEPS_ERROR
    OUTPUT_STRIP_TRAILING_WHITESPACE )

  if (NOT SHLIBDEPS_RESULT EQUAL 0)
    message (FATAL_ERROR "dpkg-shlibdeps: ${SHLIBDEPS_ERROR}")
  endif ()

  #Get rid of prefix generated by dpkg-shlibdeps
  string (REGEX REPLACE "^.*Depends=" "" CPACK_DEBIAN_PACKAGE_AUTO_DEPENDS ${SHLIBDEPS_OUTPUT})
  
  message("Found dependencies: ${CPACK_DEBIAN_PACKAGE_AUTO_DEPENDS}")

  write_dependencies_to_file(${BINARY_DIR}/CPackConfig.cmake ${CPACK_DEBIAN_PACKAGE_AUTO_DEPENDS})
  write_dependencies_to_file(${BINARY_DIR}/CPackSourceConfig.cmake ${CPACK_DEBIAN_PACKAGE_AUTO_DEPENDS})
  
  # Remove blank control file
  # Might not be safe if package actual contain file or directory named debian
  file(REMOVE_RECURSE "${BINARY_DIR}/tmp/debian")
  file(REMOVE_RECURSE "${BINARY_DIR}/tmp/DEBIAN")
endif()
